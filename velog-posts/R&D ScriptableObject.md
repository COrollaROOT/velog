<ul>
<li>ScriptableObject로 구현</li>
</ul>
<h1 id="scriptableobject란">ScriptableObject란?</h1>
<p>클래스의 인스턴스와 별도로 대량의 데이터를 저장하고 사용가능한 데이터 컨테이너 값의 사본이 생성되는 것을 방지 프로젝트의 메모리 사용을 줄일수 있다</p>
<h2 id="사용-목적">사용 목적</h2>
<h3 id="효율적인-팀-협업">효율적인 팀 협업</h3>
<ul>
<li><p>기획자 또는 아티스트와 디자이너가 쉽게 접근할수 있습니다
이는 코드를 편집할 필요 없이 ScriptableObject를 사용해 프로젝트의 게임 로직을 설정&amp;적용 할수 있습니다</p>
</li>
<li><p>에디터를 통해 편리하게 ScriptableObject를 확인 및 편집 할수 있으므로
디자이너 또는 기획자는 프로그래머의 도움 없이 게임플레이 데이터를 설정할수 있습니다</p>
</li>
<li><p>ScriptableObject를 추가하여 NPC의 동작을 적용하는 등의 게임 로직 측면에서
활용할수 있는 장점이 있습니다</p>
</li>
<li><p>협업자끼리 같은 프리팹이나 씬을 수정할때 단일 MonoBehaviour에 데이터나 로직을 저장하면 병합시 충돌이 발생하여 수정하는 많은 시간을 소요 할수 있습니다</p>
</li>
<li><p>ScriptableObject로 공유 데이터를 더 작은 파일과 에셋으로 분활하면 기획자 또는 디자이너는 테스트 전에 프로그래머가 코드로 게임 플레이를 설정하는 동안 기다리지 않고 프로그래머와 동시에 게임 빌드에 관여 할수 있습니다</p>
</li>
<li><p>서로 다른 프로그래머가 게임코드와 에셋을 동시에 액세스하면 문제가 발생 합니다
이에 ScriptableObject를 사용하면 프로젝트의 어떤 부분을 에디터에서 편집할 수 있는지 프로그래머가 제어할 수 있게 됩니다</p>
</li>
<li><p>ScriptableObject로 코드 구성시 더 모듈화되고 효율적인 테스트가 가능합니다</p>
</li>
</ul>
<h3 id="데이터-컨테이너">데이터 컨테이너</h3>
<ul>
<li><p>ScriptableObject를 사용하면 로직에서 데이터를 분리하여 클린 코딩 프랙티스를 촉진하는 데 도움이 됩니다
로직에서 데이터를 분리하면 예상치 못한 부작용 없이 변경 사항을 쉽게 적용할 수 있으며 테스트 가능성도 향상됩니다</p>
</li>
<li><p>ScriptableObject는 정적 데이터 저장에 특화 되있습니다
아이템 또는 NPC 능력치 설정, 캐릭터 대화 등 정적 게임플레이 값을 설정하는데 유용합니다</p>
</li>
<li><p>ScriptableObject는 에셋으로 저장되어 게임 모드에서 벗어나도 유지되기 때문에 런타임에 동적으로 변경되는 정적 설정으로 로드하는데 사용할 수 있습니다</p>
</li>
<li><p>MonoBehaviour는 호스트 역활을 할 게임 오브젝트와 트랜스폼(기본값)이 필요하기 때문에(단일 값을 저장하기 전에 다량의 미사용 데이터를 생성) 추가 오버헤드가 발생 합니다
ScriptableObject는 이러한 매모리 사용량을 줄이고 게임 오브젝트와 트랜스폼의 수를 줄입니다</p>
</li>
<li><p>일반적으로 많은 게임 오브젝트가 런타임 시 변경할 필요 없는 중복 데이터에 의존합니다 각 게임 오브젝트에 중복 데이터 대신 ScriptableObject를 연동하면
각 오브젝트는 데이터 자체를 복사하는 대신 공유 데이터 에셋에 대한 레퍼런스를 저장합니다 이러면 오브젝트 수가 많은 프로젝트에서 성능을 올릴수 있습니다</p>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/c74e04b8-9f0c-4f1a-9e40-a0e93e67b9ee/image.png" /></p>
<p>중복 로컬 데이터를 사용하는 오브젝트가 많으면 성능 효율성이 떨어집니다</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/858f4538-544c-4047-840a-3cb46b23205f/image.png" /></p>
<p>데이터를 복제하는 대신 ScriptableObject를 통해 공유하면 성능을 개선할 수 있습니다</p>
<h3 id="열거형">열거형</h3>
<ul>
<li><p>비교 작업의 열거형으로 ScriptableObject를 사용하는 것은 코드 간소화의 좋은 예시 입니다 ScriptableObject로 특수 대미지 효과 같은 카테고리나 아이템 유형을 나타낼 수 있습니다</p>
</li>
<li><p>아이템 장착을 위한 인벤토리 시스템이 필요한 경우 ScriptableObject로 아이템 유형이나 무기 슬롯을 나타낼 수 있습니다 Inspector의 해당 필드가 ScriptableObject 설정을 위한 드래그 앤 드롭 인터페이스로 작동 합니다</p>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/3437075e-49aa-461e-a89e-29bb749ab2f3/image.png" /></p>
<ul>
<li><p>ScriptableObject를 열거형으로 사용하면 ScriptableObject를 확장하고 데이터를 추가하는 작업이 수월해 집니다 보통의 열거형과 다른 ScriptableObject는 추가 필드와 메서드를 가질 수 있습니다</p>
</li>
<li><p>기존의 열거형에는 고정된 값 집합이 있지만, ScriptableObject 열거형은 런타임 시에도 생성 및 수정할 수있으므로 필요에 따라 값을 추가 및 제거 할수 있습니다</p>
</li>
<li><p>번호가 지정되지 않은 긴 열거형 값 목록은 열거형을 삽입하거나 제거하면 순서가 바뀔 수 있습니다 순서가 변경되면 미세한 버그나 의도치 않게 동작 할수 있습니다 ScriptableObject 기반 열거형은 매번 코드를 변경할 필요 없이 프로젝트에 열거형을 추가 및 삭제가 가능 합니다</p>
</li>
</ul>
<h3 id="델리게이트-오브젝트">델리게이트 오브젝트</h3>
<ul>
<li><p>메서드르 만드는 것이 가능하기 때문에 ScriptableObject는 데이터를 보관하는 용도로 로직이나 동작을 그대로 저장하는 데 유용하게 활용할 수 있습니다
MonoBehaviour에서 ScriptableObject로 로직을 옮기면 ScriptableObject를 델리게이트 오브젝트로 사용하여 동작을 더 모듈화할 수 있습니다</p>
</li>
<li><p>특정 작업을 수행해야 하는 경우 해당 알고리즘을 전용 오브젝드로 캡슐화할 수 있습니다 결과적으로 동작이 서로 다른 여러 ScriptableObject가 파생되어 각 에셋을 서로 바꿔 사용할 수 있으므로 동작을 연결할 수 있습니다</p>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/79f85755-6ec8-4357-93e1-29153f54c117/image.png" /></p>
<h3 id="이벤트-채널">이벤트 채널</h3>
<ul>
<li><p>대규모 프로젝트에선 여러 게임 오브젝트에서 데이터나 상태를 공유하되 해당 오브젝트 간의 직접적인 참조는 방지해야 할 때 문제가 발생 합니다
이러한 종속 관계를 대규모로 관리할때 막대한 노력이 발생 버그의 원인이 될 수 있습니다</p>
</li>
<li><p>게임 오브젝트 통신에 도움이 되는 ScriptableObject 기반 이벤트를 사용
ScriptableObject로 Observer pattern(관찰자 디자인 패턴)의 형태로 구현 합니다
주체는 분리된 하나 이상의 Observer(관찰자)에게 메세지르 브롣 캐스트 하여 관찰하는 각 오브젝트는 주체로부터 독립적으로 반응할 수 있지만 다른 관찰자는 인식 하지 못합니다
이러한 주체를 '퍼블리셔'또는'브로드 캐스터'라 부르고 관찰자를'구독자'또는'리스너'라고 부르기도 합니다</p>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/ba4d6f36-e00e-4520-8730-a551799dd370/image.png" />
ScriptableObject 기반 이벤트 채널</p>
<ul>
<li>ScriptableObject는 에셋이므로 계층 구조에 있는 모든 오브젝트에 액세스할 수 있으며 씬을 로드해도 사라지지 않습니다
ScriptableObject는 싱글톤 패턴보다 불필요한 종속 관계를 형성하지 않고도 동일한 이점을 제공 하는 경우가 많습니다
ScriptableObject 기반 이벤트에서는 모든 오브젝트가 이벤트를 브로드캐스트하는 퍼블리셔 역할과 이벤트를 수신하는 구독자 역할을 수행하고 중간에서 신호를 릴레이하는 데 도움을 주며 중앙에서 둘 사이를 중개하는 역활을 맡습니다</li>
</ul>
<h3 id="런타임-세트">런타임 세트</h3>
<ul>
<li>런타임 시 씬의 게임 오브젝트나 컴포넌트 목록을 추적해애 하는 경우가 발생합니다 싱글톤은 간편한 전역 액세스를 제공하지만 단점도 존재 합니다
ScriptableObject에 '런타임 세트'로 저장 하면 ScriptableObject는 프로젝트 수준에서 나타납니다 모든 씬의 오브젝트가 사용 가능한 데이터를 저장할 수 있으므로 비슷한 전역 액세스를 제공 합니다 데이터가 에셋에 있으므로 공용 아이템 목록에 언제든지 액세스할 수 있습니다</li>
</ul>
<p>이처럼 ScriptableObject가 주는 이점을 확실합니다
하지만 ScriptableObject를 폭 넓게 사용하는 팀도 있고
정적 데이터로 로드하고 데이터에서 로직을 분리하는 용도로 사용을 제한하는 팀도 있습니다</p>
<p>팀과 상의후 팀에 맞는 ScriptableObject를 사용 하시길 바랍니다</p>