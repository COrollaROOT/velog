<p>리스트 (List)         </p>
<ul>
<li>런타임 중 크기를 확장할 수 있는 배열기반의 자료구조</li>
<li>배열요소의 갯수를 특정할 수 없는 경우 사용이 용이</li>
</ul>
<p>&lt;리스트 구현&gt;</p>
<ul>
<li>리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조</li>
<li>리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용</li>
</ul>
<pre><code>크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
         ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


         &lt;리스트 삽입&gt;
         중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
              ↓                        ↓                        ↓
         ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│ │ │ │ │   =&gt;   │1│2│ │3│4│ │ │ │   =&gt;   │1│2│A│3│4│ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


         &lt;리스트 삭제&gt;
         중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
              ↓                        ↓
         ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│A│3│4│ │ │ │   =&gt;   │1│2│ │3│4│ │ │ │   =&gt;   │1│2│3│4│ │ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


         &lt;리스트 용량&gt;
         용량을 가득 채운 상황에서 데이터를 추가하는 경우
         더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용

         1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
         크기 = 8, 용량 = 8
         ┌─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│5│6│7│8│ ← A 추가
         └─┴─┴─┴─┴─┴─┴─┴─┘

         2. 새로운 더 큰 배열 생성
         크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
         ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│5│6│7│8│ ← A 추가  │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

         3. 새로운 배열에 기존의 데이터 복사
         크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
         ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│5│6│7│8│ ← A 추가  │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

         4. 기본 배열 대신 새로운 배열을 사용
         크기 = 8, 용량 = 16
         ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
         └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

         5. 빈공간에 데이터 추가
         크기 = 9, 용량 = 16
         ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
         │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
         └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


         &lt;리스트 시간복잡도&gt;
         접근    탐색    삽입    삭제
         O(1)    O(n)    O(n)    O(n)</code></pre><pre><code>static void Main(string[] args)
{
    List&lt;int&gt; list = new List&lt;int&gt;();

    // 추가
    list.Add(1); // 맨뒤에 추가하기 : O(1)
    list.Add(2);
    list.Add(3);
    list.Add(4);
    list.Insert(2, 999); // 중간에 끼워넣기 : O(n)
    list.Insert(0, 111);
    list.Add(999);


    // 삭제
    list.Remove(999); // 똑같은거 찾아서 삭제하기 : O(n)
    list.RemoveAt(1); // 특정 위치에 있는 요소 지우기 : O(n)
    list.RemoveAt(555); // 찾아서 지울때 없었으면 무시 (반환은 false)


    // 접근 : O(1)
    list[1] = 222; // 리스트는 배열로 구현되어 있기 때문에 인덱스를 통한 접근이 가능하다
    int value = list[1];


    // 탐색 : O(n)
    int index = list.IndexOf(333); // 찾아서 인덱스 가져오기
    bool contain = list.Contains(333); // 찾아서 있으면 true, 없으면 false
}</code></pre><p>연결리스트 (Linked List)         </p>
<ul>
<li>데이터를 포함하는 노드들을 연결식으로 만든 자료구조</li>
<li>데이터와 다른 데이터 지점의 참조변수를 가진 노드를 기본 단위로 사용</li>
<li>데이터를 노드를 통해 연결식으로 구성하기 때문에 데이터의 추가/삭제에 유용</li>
<li>노드가 메모리에 연속적으로 배치되지 않고 연결 구조로 다른 데이터의 위치를 확인</li>
</ul>
<p>연결리스트 특징</p>
<ul>
<li>연결리스트의 경우 데이터를 연속적으로 배치하는 배열과 다르게 연결식으로 구성</li>
<li>따라서, 데이터의 추가/삭제 과정에서 다른 데이터의 위치와 무관하게 진행되므로 수월함</li>
<li>하지만, 데이터의 접근 과정에서 연속적인 데이터 배치가 아니기 때문에 인덱스 사용 불가하여 처음부터 탐색해야 함</li>
</ul>
<pre><code>         &lt;연결리스트 구현&gt;
         연결리스트는 노드를 기본 단위로 연결식으로 구현
         노드간의 연결구조에 따라 단방향, 양방향, 환형 으로 구분

         1. 단방향 연결리스트
         노드가 다음 노드를 참조
         ┌────┬─┐  ┌────┬─┐  ┌────┬─┐  ┌────┬─┐
         │Data│───→│Data│───→│Data│───→│Data│ │
         └────┴─┘  └────┴─┘  └────┴─┘  └────┴─┘

         2. 양방향 연결리스트
         노드가 이전/다음 노드를 참조
         ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐
         │ │Data│←────→│Data│←────→│Data│←────→│Data│ │
         └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘

         3. 환형 연결리스트
         노드가 이전/다음 노드를 참조하며, 시작 노드와 마지막 노드를 참조
          ┌──────────────────────────────────────────┐
         ┌│┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬─┐  ┌─┬────┬│┐
         │↓│Data│←────→│Data│←────→│Data│←────→│Data│↓│
         └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘  └─┴────┴─┘


         &lt;연결리스트 삽입&gt;
         새로 추가하는 노드가 이전/이후 노드를 참조한 뒤
         이전/이후 노드가 새로 추가하는 노드를 참조함

                  ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐ 
                  │ │ C │ │                    ┌───│ C │───┐                  ┌───│ C │───┐
                  └─┴───┴─┘          =&gt;        ↓ └─┴───┴─┘ ↓        =&gt;        ↓ └─┴───┴─┘ ↓
         ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐    ┌─┬───┬─┐ ↑     ↑ ┌─┬───┬─┐
         │ │ A │←───────────→│ B │ │    │ │ A │←───────────→│ B │ │    │ │ A │───┘     └───│ B │ │
         └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


         &lt;연결리스트 삭제&gt;
         삭제하는 노드의 이전 노드가 이후 노드를 참조한 뒤
         삭제하는 노드의 이후 노드가 이전 노드를 참조함

                  ┌─┬───┬─┐                      ┌─┬───┬─┐                      ┌─┬───┬─┐
                ┌──→│ C │←──┐                    │ │ C │←──┐                    │ │ C │ │
                │ └─┴───┴─┘ │        =&gt;          └─┴───┴─┘ │        =&gt;          └─┴───┴─┘
         ┌─┬───┬│┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌│┬───┬─┐    ┌─┬───┬─┐         ┌─┬───┬─┐
         │ │ A │↓│         │↓│ B │ │    │ │ A │──────────→│↓│ B │ │    │ │ A │←───────────→│ B │ │
         └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘    └─┴───┴─┘         └─┴───┴─┘


         &lt;LinkedList의 시간복잡도&gt;
         접근    탐색    삽입    삭제
         O(n)    O(n)    O(1)    O(1)</code></pre><pre><code>static void Main(string[] args)
{
    LinkedList&lt;string&gt; linkedList = new LinkedList&lt;string&gt;();

    // 삽입
    LinkedListNode&lt;string&gt; node0 = linkedList.AddFirst(&quot;0 데이터&quot;); //O(1)
    LinkedListNode&lt;string&gt; node1 = linkedList.AddFirst(&quot;1 데이터&quot;); //O(1)
    LinkedListNode&lt;string&gt; node2 = linkedList.AddLast(&quot;2 데이터&quot;); //O(1)
    LinkedListNode&lt;string&gt; node3 = linkedList.AddLast(&quot;3 데이터&quot;); //O(1)
    LinkedListNode&lt;string&gt; node4 = linkedList.AddBefore(node0, &quot;4 데이터&quot;); //O(1)
    LinkedListNode&lt;string&gt; node5 = linkedList.AddAfter(node0, &quot;5 데이터&quot;); //O(1)


    // 삭제
    linkedList.Remove(&quot;1 데이터&quot;); //O(n)
    linkedList.Remove(node1); //O(1)
    linkedList.RemoveFirst(); //O(1)
    linkedList.RemoveLast(); //O(1)


    // 접근 
    //LinkedList[1] : 연결리스트는 인덱스가 없다(연속적으로 저장하지 않기 때문에 인덱스 사용이 불가능하다)
    LinkedListNode&lt;string&gt; prevNode = node0.Previous; // 이전
    LinkedListNode&lt;string&gt; nextNode = node0.Next; // 다음
    LinkedListNode&lt;string&gt; firstNode = linkedList.First; // 처음
    LinkedListNode&lt;string&gt; lastNode = linkedList.Last; // 마지막




    // 탐색
    LinkedListNode&lt;string&gt; findNode = linkedList.Find(&quot;1 데이터&quot;);
    bool contain = linkedList.Contains(&quot;1 데이터&quot;);
}</code></pre><p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/9dfcd5df-eb89-4ae6-9291-aa8f97d0b35c/image.png" /></p>