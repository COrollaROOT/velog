<h1 id="알고리즘-algorithm">알고리즘 (Algorithm)</h1>
<ul>
<li>문제를 해결하기 위해 정해진 진행절차나 방법</li>
<li>컴퓨터에서 알고리즘은 어떠한 행동을 하기 위해서 만들어진 프로그램명령어의 집합</li>
</ul>
<h1 id="알고리즘-조건">알고리즘 조건</h1>
<ol>
<li>입력 : 알고리즘은 0개 이상의 입력을 가져야 함</li>
<li>출력 : 알고리즘은 최소 1개 이상의 결과를 가져야 함</li>
<li>명확성 : 수행 과정은 모호하지 않고 정확한 수단을 제공해야 함</li>
<li>유한성 : 수행 과정은 무한하지 않고 유한한 작업 이후에 정지해야 함</li>
<li>효과성 : 모든 과정은 명백하게 실행 가능해야 함</li>
</ol>
<h1 id="알고리즘의-설계-과정">알고리즘의 설계 과정</h1>
<p>문제 이해 -&gt; 예시와 테스트 케이스 작성 -&gt; 알고리즘 설계 -&gt; 알고리즘 구현 및 검증 -&gt; 알고리즘 분석과 개선</p>
<h4 id="문제의-이해">문제의 이해</h4>
<ul>
<li>알고리즘을 풀어내는 방법은 개개인별로 다르지만, 먼저 해야 할 것은 명확합니다.</li>
<li>가장 먼저 해야 할 것은, 문제의 요구사항을 분석하고 입력과 출력의 형식을 파악하는 것 입니다.</li>
</ul>
<h4 id="예시와-테스트-케이스-작성">예시와 테스트 케이스 작성</h4>
<ul>
<li><p>해결하여야 할 알고리즘의 입력의 형태와 출력의 형태가 파악 되었다면, 몇 가지 예시를 들어서 무엇을 넣었을 시에 어떤 결과를 도출해야 하는지 파악해둘 필요가 있습니다.</p>
</li>
<li><p>이를 보고 테스트 케이스를 작성한다고 표현하는데, 예를 들어, 주어진 문제가 다음과 같다고 가정하겠습니다char형 배열과 양의 정수 n이 하나 주어지면, 주어진 배열에서 n번째에 있는 요소를 반환하는 기능 제작.</p>
</li>
<li><p>이런 알고리즘이 주어졌을 때, [apple,2] 의 예상 결과로는 p, [banana,1] 의 예상 결과로 b가 도출된다는 것들을 테스트 케이스로 작성해 두면 알고리즘의 정상 동작 여부를 확인할 수 있습니다.</p>
</li>
</ul>
<h4 id="알고리즘-설계">알고리즘 설계</h4>
<p>문제를 해결하기 위한 본인만의 알고리즘을 구상해보는 단계입니다.
최우선 목표는 정확도이며, 그 다음으로 고려해야 할 것은 알고리즘의 효율성, 즉 BigO 값입니다. 설계를 할 때에는 바로 코드를 치는것 보다는 의사코드(pseudo 코드) 혹은 흐름도를 먼저 그리는 것이 좋습니다. 여기서 의사코드란, 실제 코드가 아닌 인간의 언어에 더욱 가까운 코드를 의미하는데, 다음과 같습니다.</p>
<pre><code>while(b가 100보다 작다면?)
{
  i를 1 올린다;
  if(배열의 i번째 요소가 10보다 크다면?)
    {
      b를 제곱 시킨다;
      n도 올려서 총 b가 몇번 제곱되었는지 측정;
    }
}</code></pre><p>추후 실제 코드로 해당 내용을 구현할 목적으로, 위와 같이 인간의 언어로 먼저 대충 적어놓은 코드를 보고 의사코드라고 부릅니다.
의사코드는 정해진 틀이 없으며, 더욱 추상적이고 세분화 하여도 상관 없습니다.</p>
<h4 id="알고리즘-구현-및-검증">알고리즘 구현 및 검증</h4>
<ul>
<li>설계에서 만든 의사코드나 흐름도에 따라 코드를 작성합니다. 제작 후에는 사전에 만들어 둔 테스트 케이스를 통해 검증을 거치면 됩니다.
정확도가 중요한 프로그램이라면 알고리즘의 타당성을 검증하기 위한 테스트케이스를 만들어주는 프로그램을 작성하기도 합니다.</li>
</ul>
<h4 id="알고리즘-분석과-개선">알고리즘 분석과 개선</h4>
<ul>
<li>작동이 정상적이라면 성능 분석을 통해 최적화, 개선의 여지가 있는지 확인합니다.</li>
</ul>
<h1 id="알고리즘-설계기법">알고리즘 설계기법</h1>
<h1 id="algorithm-design-technique">(Algorithm Design Technique)</h1>
<ul>
<li><p>어떤 문제를 해결하는 과정에서 해당 문제의 답을 효과적으로 찾아가기 위한 전략과 접근 방식</p>
</li>
<li><p>문제를 풀 때 어떤 알고리즘 설계 기법을 쓰는지에 따라 효율성이 막대하게 차이</p>
</li>
<li><p>문제의 성질과 조건에 따라 알맞은 알고리즘 설계기법을 선택하여 사용</p>
</li>
</ul>
<h1 id="재귀-recursion">재귀 (Recursion)</h1>
<ul>
<li><p>어떠한 것을 정의할 때 자기 자신을 참조하는 것</p>
</li>
<li><p>함수를 정의할 때 자기자신을 이용하여 표현하는 방법</p>
</li>
</ul>
<h2 id="재귀함수의-조건">재귀함수의 조건</h2>
<ul>
<li><ol>
<li>함수내용 중 자기자신 함수를 다시 호출해야 한다.</li>
</ol>
</li>
<li><ol start="2">
<li>종료조건이 있어야 한다.</li>
</ol>
</li>
</ul>
<p>재귀함수 장점</p>
<ol>
<li>코드로 표현하기 어려운 경우도 직관적이고 처리가 가능</li>
<li>분할정복을 통한 반절 계산이 가능해서 효율이 높아지게 구현이 가능<h2 id="재귀함수-사용">재귀함수 사용</h2>
</li>
</ol>
<p>Factorial : 정수를 1이 될 때까지 차감하며 곱한 값
x! = x * (x-1)!;
1! = 1;
ex) 5! = 5 x 4!
       = 5 x 4 x 3!
       = 5 x 4 x 3 x 2!
       = 5 x 4 x 3 x 2 x 1!
       = 5 x 4 x 3 x 2 x 1</p>
<pre><code>int Factorial(int x)
{
    if (x == 1)
        return 1;
    else
        return x * Factorial(x - 1);
}</code></pre>