<h1 id="git과-협업">Git과 협업</h1>
<p>Git은 협업에서 매우 강력하고, 필수적으로 사용되는 수단입니다. </p>
<p>만약 Git이 없다면 팀 프로젝트를 진행하면서 버전 관리에 큰 어려움을 겪게 될겁니다.</p>
<h2 id="git의-기능">Git의 기능</h2>
<p>Git은 '버전 관리'와 '협업'의 수단으로서 사용합니다. Commit과 Push 외에도 원활한 버전관리를 위한 다양한 기능이 존재합니다. </p>
<ul>
<li><p>Branch와 Merge</p>
</li>
<li><ul>
<li>브랜치(Branch)는 특정 시점에서 '분기'를 만듭니다.
작업자는 대상 브랜치에서 작업 후 Main 브랜치로 다시 병합(Merge)하며 Main 브랜치의 작업물이 업데이트 됩니다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Commit과 Push</p>
</li>
<li><ul>
<li>작업물이 git에 업로드 되는 과정은 Local 작업 - Staging - Commit - Push 순으로 이뤄집니다.
로컬 환경에서 작업하던 결과물을 GitHub Desktop이 자동으로 인식해 Staging 작업을 진행합니다. 그 후 사용자가 메세지와 함께 Commit(게시)하고, Git Repository로 밀어넣는(Push)를 실행해 업로드를 진행합니다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>CheckOut</p>
</li>
<li><ul>
<li>과거의 Commit 이력의 내용을 확인하며, 이때 로컬 저장소는 해당 시점으로 갱신됩니다.
이 내용은 버전관리의 핵심이며, 추후 버그 및 에러 발생시 경로를 추적하는 용도로 자주 활용합니다.</li>
</ul>
</li>
<li><p>Reset과 Revert</p>
</li>
<li><ul>
<li>리셋과 리버트, 둘 다 작업내역을 삭제하고 이전으로 되돌리는 롤백 작업이지만 방식이 다릅니다. Reset은 이전 커밋으로 CheckOut 후 최근 작업내역을 삭제하기 때문에 작업이력이 남지 않습니다.
Revert는 현재 작업이력을 남겨놓은 상태로 새로운 커밋을 생성해 되돌리고자 하는 시점의 커밋을 복사해옵니다.
이 차이를 알고 활용할 수 있다면 문제 발생 시 유연하게 대처가 가능합니다.</li>
</ul>
</li>
<li><p>Git Graph</p>
</li>
<li><ul>
<li>Git Graph는 Git저장소를 더 직관적으로 관리하고 협업을 향상시키는데 유용한 도구 입니다.</li>
</ul>
</li>
</ul>
<h3 id="git-graph가-제공하는-기능">Git Graph가 제공하는 기능</h3>
<ul>
<li><p>커밋 시각화
각 커밋, 브랜치, 머지 등의 Git 작업 과정을 시각적으로 표시하여 프로젝트의 히스토
리를 한눈에 파악할 수 있습니다.</p>
</li>
<li><p>브랜치 관리
브랜치의 생성, 병합, 삭제 등의 과정을 그래프 형태로 보여주어 브랜치 관리를 쉽게 할 수 있습니다.</p>
</li>
<li><p>커밋 비교
두 커밋 사이의 차이를 시각적으로 비교하여 변경 사항을 파악할 수 있습니다.</p>
</li>
<li><p>Git 명령어 실행
Git Graph를 통해 push, pull, commit 등의 Git 명령어를 클릭만으로 쉽게 실행할 수 있습니다. </p>
</li>
</ul>
<h3 id="git-graph를-사용하는-이유">Git Graph를 사용하는 이유</h3>
<ul>
<li><p>Git 사용 초보자
Git의 복잡한 명령어를 사용하지 않고도 Git 작업을 시각적으로 이해할 수 있어 Git 사용을 시작하기에 좋습니다.</p>
</li>
<li><p>프로젝트 관리
프로젝트의 커밋 히스토리, 브랜치 구조 등을 쉽게 파악하여 프로젝트 관리에 도움이 됩니다.</p>
</li>
<li><p>협업
팀원 간의 협업을 돕고, 코드 변경 사항을 쉽게 공유하고 논의할 수 있습니다. </p>
</li>
</ul>
<h1 id="git-flow">Git Flow</h1>
<p>GitHub에서 제안한 브랜치 모델로, 간단하고 빠른 개발을 위한 방법</p>
<p>Git을 효과적으로 활용하여 프로젝트 관리와 협업을 개선하고 팀의 생산성을 높이며 소프트 웨어 품질을 향상시키기 위해서 사용합니다</p>
<h3 id="git-flow-종류">Git Flow 종류</h3>
<ul>
<li><p>MASTER : 정식 버전 출시 및 빌드용 브랜치.</p>
</li>
<li><p>DEVELOP : 기능개발이 진행되는 브랜치. 기능개발 진행시 여기에서 브랜치를 파생한다.</p>
</li>
<li><p>FEATURE : 디벨롭 브랜치에서 파생되며, 담당 기능개발 후 디벨롭 브랜치로 병합한다.</p>
</li>
<li><p>RELEASE : 다음 버전 출시를 준비하는 브랜치. 디벨롭 브랜치를 여기로 옮긴 후 
QA, 테스트 진행 후 MASTER로 병합 및 정식출시한다.</p>
</li>
<li><p>HOTFIX : 정식 버전의 버그 수정 전용 브랜치</p>
</li>
</ul>
<h2 id="commit-message">Commit Message</h2>
<p>커밋 메시지는 작업 타입과 진행상황을 기재하도록 합니다.</p>
<ul>
<li><ul>
<li>구성원들간 작업의 진행도를 쉽게 파악할 수 있습니다.</li>
</ul>
</li>
<li><ul>
<li>CheckOut / Reset / Revert 실행 시 세부적인 정보를 보지 않고도 시점을 알기 쉽습니다.</li>
</ul>
</li>
<li><p>팀의 상황과 작업타입에 따라 세부 규칙을 상호 합의하에 지정해 사용하는 것이 바람직합니다.</p>
</li>
<li><p>커밋 메세지는 영어로 작성하는 것이 관례이지만, 프로젝트를 진행하는 팀이나 프로젝트 목적에 따라 한글로 작성해도 무방합니다</p>
</li>
</ul>
<pre><code>&lt;유니티 프로젝트 Git 연동방법&gt;

&quot;1. 원하는 경로에 유니티 프로젝트 만들기
2. 유니티 프로젝트 만들어 질때까지 그냥 기다리기
3. 유니티 창이 뜨는것까지 확인하기
4. 깃허브 데스크탑 열기
5. 새로운 레포지토리 생성

!주의! 유니티 프로젝트랑 동일한 경로에 git 생성
ex) 유니티를 C드라이브&gt;Test폴더에 만들었다  -&gt;  깃도 C드라이브 Test 이름으로 만든다

6. Initailize ~~ Readme.MD 체크

!주의! 유니티 프로젝트랑 동일한 경로에 git 생성
Git Ignore 반드시 Unity 로 선택

7. 28~31개 정도 파일이 추가되어 있으면 정상
8. 유니티에서 아무런 파일 추가하거나 삭제해서 확인해보기

----------------------------------------------------------------------------------

1. Imports 폴더 하나 만들기 (이 Imports 폴더는 외부에서 다운받는, 저작권이 있는, 불법배포하면 안되는 파일들만 보관)
2. Imports 폴더 안에 쓸데 없는 파일 하나만 추가
3. Github Desktop에서 변경내용에 우클릭하고 git ignore folder -&gt; Assets/Imports 를 선택
4. 변경내용에 gitignore, assets/Imports.meta 두개만 있다면 괜찮은 상황, 맞는지 확인
5. Git Commit 해서 Imports 폴더안에 있는 내용은 무시하게 됨

--&lt; 패키지로 공유하여 팀플 하는 경우
Assets-&gt;Export Package로 받은 에셋을 다른 팀원에게 공유, 변경 내용이 있을때도 공유

--&lt; Imports 폴더 안에 git을 추가적으로 다루고 싶은 경우
1. Github Desktop에서 새로운 레포지토리를 만들때 경로를 Assets 폴더 안 / 이름은 Imports
2. 단, 이 레포지토리는 깃허브에 올릴때 private으로 올리자&quot;</code></pre>