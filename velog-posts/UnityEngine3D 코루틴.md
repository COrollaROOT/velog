<h1 id="코루틴coroutine">코루틴(Coroutine)</h1>
<p>작업을 다수의 프레임에 분산하여 처리하는 동기식 작업
실행을 일시정지하고 중단한 부분부터 재개하여 처리하는 것으로 작업을 분산처리함
코루틴은 스레드가 아니며 코루틴의 작업은 메인 스레드에서 실행</p>
<p>코루틴은 유니티에서 함수의 실행을 일시중지하고, 나중에 다시 이어서 실행할 수 있는 아주 유용하고 범용적으로 사용되는 개념입니다.</p>
<p>일반 함수의 반환인 return 대신 yield 키워드를 사용하며, yield 키워드 사용시 사용이 일시 중지되고 다른 코드를 실행하거나 유니티에게 제어권을 반납하고 다음 실행시 중단점부터 이어서 실행됩니다.</p>
<p>이런 동작방식 때문에 마치 비동기적으로 작업을 처리하는 것 같지만 코루틴은 라이프 사이클 내에서 직렬적으로 일을 처리하는 동기 작업입니다.</p>
<ul>
<li><p>사용이 끝나면 반드시 중지할 것</p>
</li>
<li><ul>
<li>코루틴을 실행하면 클래스 객체가 생성되며 메모리가 할당됩니다.</li>
</ul>
</li>
<li><ul>
<li>이를 별도로 해제하지 않는 상태로 반복/누적이 될 경우, 메모리 누수가 발생할 수 있습니다.</li>
</ul>
</li>
<li><p>코루틴을 변수에 담아 사용하기</p>
</li>
<li><ul>
<li>코루틴을 실행하면 클래스 객체가 생성되기 때문에, 힙 메모리에 클래스 인스턴스가 할당됩니다.</li>
</ul>
</li>
<li><ul>
<li>주기적으로 실행되어야 하는 코루틴의 경우 변수를 선언해 미리 힙에 할당해놓고, 해당 변수에 생성되는 코루틴 객체를 할당하는 방식을 사용한다면 메모리 공간을 절약하며 사용할 수 있기 때문에 메모리 단편화를 방지할 수 있습니다</li>
</ul>
</li>
</ul>
<pre><code>IEnmerrator Routine()
{
    Debog.Log(1);
    yield return 1;
}</code></pre>