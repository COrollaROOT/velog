<h1 id="버전-관리">버전 관리</h1>
<p>내용이 늘어갈수록 프로그램이 길어지고 수정할 내용들도 많아 집니다.</p>
<p>최종본을 다 만들었는데 수정을 거쳐야 할 때
하나의 작업이 길어지다보니 집에서 작업하다가 밖에
노트북을 들고 나가 이어서 작업하거나 와 같은
다른 작업환경에서 작업을 해야 할 때</p>
<p>다른 작업환경에서 작업을 해야 할 때 매번 코드를 복사해야 하는 번거로움, 그리고 잘못하면 과거 버전을 다시 작업해야 하는 상황에 놓일수도 있습니다.
이에 작업물의 버전 관리가 필요합니다.</p>
<h1 id="버전-관리를-위한-도구-git--git-hub">버전 관리를 위한 도구 [Git , Git Hub]</h1>
<p>Git은 기존 작성된 내용에서부터 생긴 변동사항을 추적하고, 변동사항들을 마치 버전처럼 관리할 수 있는 기능을 제공</p>
<p>지금 작업중인 사항에 문제가 있을 경우, 변경사항을 취소하거나 되돌리는 기능을 제공</p>
<p>더 나아가선 과거 특정 버전의 파일로 되돌아가는 기능을 제공</p>
<p>웹상의 원격 저장소에 저장이 되기에, 필요시 다른 기기에서 편리하게 업데이트 된 최신 작업본을 내려받을 수 있다.</p>
<p>협업에도 효과가 좋다. 원격 저장소에 저장되는 특성 덕분에, 여러 명의 사용자들이 동일한 파일에 작업하는 것을 조율 가능하고, 변경사항을 다른 개발자들과 공유하기에 유용</p>
<h1 id="저장소리포지토리만들기">저장소(리포지토리)만들기</h1>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/37bacd27-d153-4244-a646-9770e33fc538/image.png" /></p>
<p>Create~ 를 눌러 저장소를 만들 수 있습니다. 이러한 저장소는 리포지토리라고도 불린다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/60636062-3896-4473-979f-044fd3ea08d4/image.png" /></p>
<p>Name은 영어로 만드시는 것을 추천드립니다. Description은 한글로 적으셔도 무방</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/92f4cd4b-da50-48c9-ab2d-6793575b14aa/image.png" /></p>
<p>로컬저장소는 만들어 진 상황이고, Publish repository를 누르게 되면 원격 저장소에 올라가게 됩니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/6e616316-1a8b-4043-8632-871b8aa69859/image.png" /></p>
<p>본인 혹은 본인이 초대한 사람만 보이게 하려면 프라이빗에 체크하면 되지만, 해당 체크박스는 현업에 가기 전까진 체크를 하지 않으시는 것을 추천 구직활동을 시작할 때, 기업들이 지원자들의 포트폴리오 확인을 위해 깃허브를 확인하는데 전부 프라이빗으로 되어있으면 작업물을 확인할 수 없기 때문</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/5ddc6b7e-f7d7-456b-8d72-a934a8d1d79a/image.png" /></p>
<p>퍼블리시까지 되었다면 이제 웹으로 가서 확인해보면, 본인이 만든 리포지토리가 정상적으로 나오는 것을 볼 수 있다.</p>
<h1 id="git-과정">Git 과정</h1>
<p>현재 컴퓨터(Git Hub Desktop)에 있는 저장소는 로컬 저장소, 그리고 (Web Git Hub)에서 확인 가능한 저장소를 원격 저장소라고 부른다.</p>
<p>Git Hub 데스크탑은 로컬 저장소에 파일을 추가, 삭제하거나 수정한 내역을 추적하고 해당 내용을 버전별로 관리하거나 더 나아가선 이 버전들을 원격 저장소로 올리고 내려받는 역할을 수행한다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/1aec761a-d715-4072-89ca-310b15e13f92/image.png" /></p>
<ul>
<li><p>Working Directory라고 적힌 것은 저희가 작업중인 폴더입니다. 해당 폴더에서 파일 추가, 삭제, 수정이 일어나게 되면 그 모든 내역은 추적이 됩니다.</p>
</li>
<li><p>변동 내용들이 git add를 통해 차곡차곡 staging area에 모입니다. 파일 하나만 변했는데 새로운 버전을 만들어버리면 무수히 많은 버전들이 생겨날 것이기 때문에, 반영하고자 하는 변동사항들을 잠시 차곡차곡 모아두는 곳이라고 생각하시면 됩니다.</p>
</li>
<li><p>스테이징 공간에 add를 통해 모인 변동사항들에 git commit 과정을 거치게 되면 하나의 버전이 만들어 지게 됩니다. 이러한 버전들은 로컬 저장소에 차곡차곡 쌓입니다.</p>
</li>
<li><p>문제가 생기거나 버그를 수정할 목적으로 과거 차곡차곡 쌓아두었던 특정 버전으로 돌아갈 수도 있습니다. 해당 내용은 check out commit이라고 하지만
절대 과거로 돌아가서 내용을 바꾸는 붕괴를 일으키지 마세요.</p>
</li>
<li><p>로컬 공간에서 git Push를 진행하게 되면, 연동되어있는 원격 저장소에 올라가게 됩니다. 원격 저장소에 올라가게 되면, 해당 원격 저장소를 볼 수 있는 다른 사람 혹은 본인이 다른 컴퓨터로 해당 원격 저장소를 보게 되면 변동사항들 및 최신 코드를 볼 수 있는것 입니다.</p>
</li>
<li><p>타인과 협업을 하고 있거나, 본인이 여러 작업 공간에서 코드를 작성하고 푸쉬하였다면, 원격 저장소에 변동 사항이 생겨있을것이고, 이는 fetch 기능을 통해 가져올 수 있습니다. git Pull은 fetch로 가져온 변동사항을 바로 본인 코드에 합치는 과정까지 포함되어 있습니다. 이러한 코드 합치는 과정을 Merge라고 부릅니다.</p>
</li>
<li><p>Pull을 받아보았는데, 만약 본인이 현재 작성중인 코드가 타인에 의해 변경되었을 경우, 변동사항을 바로 반영할 수가 없고 Merge Conflict라는 문제가 발생할 것입니다.</p>
</li>
</ul>
<h1 id="add-commit-push">add, commit, push</h1>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/e379edd0-a9aa-4587-a4f6-bc9c8ba70a7d/image.PNG" /></p>
<p>초록색 플러스 버튼이 활성화 된 것을 볼 수 있습니다. 파일 중, cs확장자를 가진 파일을 클릭해보면, 세부적으로 코드도 볼 수 있음이 확인 할 수 있습니다.
이건,변동 사항을 Git Hub Desktop이 감지하여 해당 내역들을 전부 모아둔 것입니다. Git 흐름도로 보면 이 모든 사항들이 자동으로 add되어 스테이징화 되어있다고 생각하시면 됩니다. 각 항목별로 체크박스가 있는데, 체크 해제를 할 경우, 변동사항을 이번 스테이징에 반영하지 않을 수 있습니다</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/9e7a3eb4-15e5-4d34-85dd-d88df302e9e8/image.png" /></p>
<p>현재까지 모인 변동사항들을 하나로 묶어 하나의 버전으로 만드는 작업을 해보겠습니다. 버전의 제목을 적어주고, Description에는 해당 버전에 어떤 변경점이 있는지 적어주시면 됩니다.
협업시, 타인이 버전의 제목만 보아도 어떤 차이점이 있는지를 한눈에 볼 수 있게, 그리고 미래의 본인이 어느 버전에 어떤 변경점을 만들어 냈는지를 쉽게 알아보기 위해 제목과 속내용을 통일성 있게 잘 적어주는 것이 좋습니다.</p>
<p>제목에 절대 시간 달지마시오!!!!!!</p>
<p>이러한 제목과 내용을 적는 것을 Commit message라고 부르는데, 개인 작업시엔 본인 취향에 맞는 스타일을 찾아 작성하되, 협업시엔 회사지침, 팀장의 지시에 따라 통일된 방식으로 작성 합니다. 작성 후 Commit to main을 눌러줍니다</p>
<p>History를 눌러보면 커밋시킨 이력들을 확인할 수 있습니다</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/05e82e6c-7019-4da0-ba06-709429dba24b/image.png" /></p>
<p>원격 Git Hub (Web Git Hub) 저장소로 가서 새로고침을 해 보아도, 아까 Commit하였던 내용이 올라와있지 않은 것을 볼 수 있다. 그 이유는 만든 Commit들은 Push를 하기 전까진 로컬 저장소(Git Hub Desktop)에만 있고, Push를 해야만 비로소 원격 저장소(Web Git Hub)에 올라가기 때문이다.</p>
<p>로컬 저장소에서 Push 버튼을 눌러 원격 저장소로 커밋들을 밀어넣는 과정을 실행 합니다</p>
<p>웹으로 와서 새로고침 하면 이제 원격 저장소에도 올라가 있는 것을 볼 수 있습니다.</p>
<h1 id="복구나-운영에-실패한-관리자는-용서받을-수-있어도-백업에-실패한-관리자는-용서할-수-없다">&quot;복구나 운영에 실패한 관리자는 용서받을 수 있어도, 백업에 실패한 관리자는 용서할 수 없다&quot;</h1>
<p>로컬 저장소, 즉 개인 PC에는 예기치 못한 상황들이 발생할 수 있고, 항상 백업을 버전별로 잘 해두는 습관을 들이는 것이 중요</p>
<p>프로그래머에게 있어서 데이터는 무형의 재산 입니다.</p>
<h1 id="clone">clone</h1>
<p>내려받는 방법을 알아볼 차례
클론은 복제본을 만든다는 뜻으로, 원격 저장소 내용을 로컬 저장소에 복제품을 만들어 낸다는 뜻</p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/cd5c2cde-f06c-4042-83b0-0b0b9acd1655/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/a22313a6-53f3-4b1c-8a71-71f3c244df75/image.png" /></p>
<ul>
<li>방법 1 : Git Hub Desktop에서 Clone repository를 눌러 GitHub.com 탭에 본인 계정으로 보유중인 원격 저장소 목록들 중 로컬 저장소로 저장하고자 하는 저장소를 클릭 후, 저장할 위치를 아래 choose를 통해 지정해주신 후, clone을 누르시면 원격 저장소에서 로컬 저장소로 최신 커밋본이 받아진다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/zxc0cc/post/e75de5d6-121c-40a7-a5a0-62d253421394/image.png" /></p>
<ul>
<li>방법 2 : 깃허브 페이지, 즉 본인의 원격 저장소에서 코드 버튼을 누르면 해당 프로젝트 파일을 zip 형태로 다운 받는 방법, 깃허브 데스크탑을 바로 실행시키는 방법</li>
</ul>
<h1 id="fetch-merge-pull">fetch, merge, pull</h1>
<p>만약 본인이 가진 Commit 버전이 원격 저장소보다 구형이라면, 해당 내용을 내려받아야 한다.</p>
<p>로컬 저장소에서 Fetch라는 이 버튼이 하는 역할은 원격 저장소에 만약 본인 로컬 저장소에는 존재하지 않는 Commit이 있는지 체크해주는 버튼입니다. 그렇기에 언제 마지막으로 확인하였는지 시간이 기입되어 있습니다.</p>
<p>변동사항을 만들어 내면 GitHub에는 존재하지만 저희 로컬 머신에는 존재하지 않는 커밋을 발견하였다며 Pull Origin이라는 버튼이 활성화 된다.</p>
<p>로컬 저장소의 커밋들을 원격 저장소에 밀어넣는 것을 Push, 원격 저장소에 있는 커밋들을 로컬 머신으로 땡겨오는 것을 Pull이라고 부릅니다.</p>
<p>Pull을 하게 되면 변동사항을 저희가 작성한 코드에 반영을 하여 로컬 머신도 이제 최신화 된 Commit을 사용하게 됩니다.</p>
<p>변동사항이 기존 파일과 병합되어 최신본이 되는 것을 보고 merge라고 부릅니다.</p>
<h1 id="merge-conflict">merge conflict</h1>
<p>merge는 Git에서 두 개의 branch를 하나로 통합하는 과정</p>
<ul>
<li><p>merge의 기본 단위는 브랜치이고, 브랜치간의 병합을 가능하게 해주고 merge를 통해 코드의 다양한 버전을 효과적으로 관리할 수 있다.</p>
</li>
<li><p>merge는 특히 협업 환경에서 중요한 역할을 하며, 프로젝트의 다양한 기능 개발이나 버그 수정 작업을 병렬로 진행한 후, 이를 메인 프로젝트 코드와 합칠 때 주로 사용한다.</p>
</li>
</ul>
<p>원칙상으로는 fetch-&gt;Pull-&gt;Push 순서로 진행되어야 하지만
혼자 작업하는 것이 아니라 두명 이상 협업을 진행 할땐 서로 충돌이 일어 날수 있습니다.
같은 코드에 두가지 변동사항이 충돌하여 conflict가 발생할 수 있습니다.</p>
<h2 id="merge를-할-때-conflict를-해결하는-것은-git-사용법에서-핵심-중의-핵심">merge를 할 때 conflict를 해결하는 것은 Git 사용법에서 핵심 중의 핵심</h2>
<h1 id="삭제">삭제</h1>
<p>저장소 제거에 있어서 정말로 중요한 것은 순서입니다.</p>
<p>만약 공용PC라서 프로젝트를 삭제하고 갈 상황이라면 순서는 다음과 같습니다.</p>
<ul>
<li><p>공용PC서 작업한 최종 로컬 커밋을 생성한다.</p>
</li>
<li><p>최종 로컬 커밋을 원격 저장소에 푸쉬한다</p>
</li>
<li><p>Remove 및 체크박스를 클릭하여 모든 삭제를 진행</p>
</li>
<li><p>이 과정이 순서가 잘못되어, 로컬 파일들 삭제, 커밋푸쉬, 깃허브 데스크탑에서 Remove, 순으로 진행되어버리면, 컴퓨터는 가장 최신화된 커밋에 모든 파일이 다 삭제된 이력이 담기게 되어버릴 것 입니다.</p>
</li>
</ul>